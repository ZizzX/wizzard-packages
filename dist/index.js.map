{"version":3,"sources":["../src/context/WizardContext.tsx","../src/adapters/persistence/MemoryAdapter.ts","../src/hooks/useWizard.ts","../src/adapters/persistence/LocalStorageAdapter.ts","../src/adapters/validation/ZodAdapter.ts","../src/adapters/validation/YupAdapter.ts"],"sourcesContent":["import React, { createContext, useContext, useEffect, useMemo, useState, useCallback } from 'react';\r\nimport type {\r\n  IWizardConfig,\r\n  IWizardContext,\r\n  PersistenceMode,\r\n  IPersistenceAdapter,\r\n} from '../types';\r\nimport { MemoryAdapter } from '../adapters/persistence/MemoryAdapter';\r\n\r\nconst WizardContext = createContext<IWizardContext<any> | undefined>(undefined);\r\n\r\ninterface WizardProviderProps<T> {\r\n  config: IWizardConfig<T>;\r\n  initialData?: T;\r\n  children: React.ReactNode;\r\n}\r\n\r\nexport function WizardProvider<T extends Record<string, any>>({\r\n  config,\r\n  initialData,\r\n  children,\r\n}: WizardProviderProps<T>) {\r\n  const [currentStepId, setCurrentStepId] = useState<string>('');\r\n  const [wizardData, setWizardData] = useState<T>((initialData || {}) as T);\r\n  const [visitedSteps, setVisitedSteps] = useState<Set<string>>(new Set());\r\n  const [completedSteps, setCompletedSteps] = useState<Set<string>>(new Set());\r\n  const [errorSteps, setErrorSteps] = useState<Set<string>>(new Set());\r\n  const [allErrors, setAllErrors] = useState<Record<string, Record<string, string>>>({});\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n\r\n  // Persistence Setup\r\n  const persistenceAdapter = useMemo<IPersistenceAdapter>(() => {\r\n    return config.persistence?.adapter || new MemoryAdapter();\r\n  }, [config.persistence?.adapter]);\r\n\r\n  const persistenceMode = config.persistence?.mode || 'onStepChange';\r\n\r\n  // Calculate Active Steps (Conditional Logic)\r\n  const activeSteps = useMemo(() => {\r\n    return config.steps.filter((step) => {\r\n      if (step.condition) {\r\n        return step.condition(wizardData);\r\n      }\r\n      return true;\r\n    });\r\n  }, [config.steps, wizardData]);\r\n\r\n  // Set initial step if not set\r\n  useEffect(() => {\r\n    if (!currentStepId && activeSteps.length > 0) {\r\n      setCurrentStepId(activeSteps[0].id);\r\n      setIsLoading(false);\r\n    }\r\n  }, [activeSteps, currentStepId]);\r\n\r\n  // Derived state\r\n  const currentStep = useMemo(() => activeSteps.find((s) => s.id === currentStepId) || null, [activeSteps, currentStepId]);\r\n  const currentStepIndex = useMemo(() => activeSteps.findIndex((s) => s.id === currentStepId), [activeSteps, currentStepId]);\r\n  const isFirstStep = currentStepIndex === 0;\r\n  const isLastStep = currentStepIndex === activeSteps.length - 1;\r\n\r\n  // Constants\r\n  const META_KEY = '__wizzard_meta__';\r\n\r\n  // Hydration Helper\r\n  const hydrate = useCallback(() => {\r\n    setIsLoading(true);\r\n    \r\n    // 1. Load Metadata (Current Step, Visited, etc.)\r\n    const metaFn = persistenceAdapter.getStep<{\r\n      currentStepId: string;\r\n      visited: string[];\r\n      completed: string[];\r\n    }>(META_KEY);\r\n\r\n    if (metaFn) {\r\n       if (metaFn.currentStepId) setCurrentStepId(metaFn.currentStepId);\r\n       if (metaFn.visited) setVisitedSteps(new Set(metaFn.visited));\r\n       if (metaFn.completed) setCompletedSteps(new Set(metaFn.completed));\r\n    }\r\n\r\n    // 2. Load Data\r\n    // We assume data is distributed across steps OR stored centrally.\r\n    // Given the current implementation saves 'wizardData' to each stepId, \r\n    // we can iterate steps.\r\n    const loadedData: Partial<T> = {};\r\n    config.steps.forEach(step => {\r\n       const stepData = persistenceAdapter.getStep(step.id);\r\n       if (stepData) {\r\n         Object.assign(loadedData, stepData);\r\n       }\r\n    });\r\n\r\n    if (Object.keys(loadedData).length > 0) {\r\n        setWizardData(prev => ({ ...prev, ...loadedData }));\r\n    }\r\n    setIsLoading(false);\r\n  }, [config.steps, persistenceAdapter]);\r\n\r\n  useEffect(() => {\r\n    hydrate();\r\n  }, [hydrate]);\r\n\r\n  // Save logic\r\n  const saveData = useCallback((mode: PersistenceMode, stepId: string, data: any) => {\r\n    if (mode === persistenceMode || mode === 'manual') {\r\n        persistenceAdapter.saveStep(stepId, data);\r\n        \r\n        // Also save metadata whenever we save data (if appropriate)\r\n        // Or we can save metadata explicitly on navigation.\r\n    }\r\n  }, [persistenceAdapter, persistenceMode]);\r\n\r\n  // Explicit Metadata Save\r\n\r\n  // Action: Set Step Data\r\n  const setStepData = useCallback((stepId: string, data: any) => {\r\n    setWizardData((prev) => {\r\n      const newData = { ...prev, ...data };\r\n      // Save if mode is 'onChange'\r\n      if (persistenceMode === 'onChange') {\r\n         // We must save the FULL new data, not just the partial 'data' update, \r\n         // otherwise we overwrite the storage with just the single field.\r\n         saveData('onChange', stepId, newData); \r\n      }\r\n      return newData;\r\n    });\r\n  }, [persistenceMode, saveData]);\r\n\r\n  // Action: Handle specific field change (helper)\r\n  const handleStepChange = useCallback((field: string, value: any) => {\r\n    if (!currentStepId) return;\r\n    setStepData(currentStepId, { [field]: value });\r\n  }, [currentStepId, setStepData]);\r\n  \r\n  // Validation Logic\r\n  const validateStep = useCallback(async (stepId: string): Promise<boolean> => {\r\n    const step = config.steps.find(s => s.id === stepId);\r\n    if (!step) return true;\r\n    \r\n    // Check if adapter exists\r\n    if (!step.validationAdapter) return true;\r\n\r\n    const result = await step.validationAdapter.validate(wizardData);\r\n    \r\n    if (!result.isValid) {\r\n      setAllErrors(prev => ({\r\n        ...prev,\r\n        [stepId]: result.errors || {}\r\n      }));\r\n      setErrorSteps(prev => new Set(prev).add(stepId));\r\n      return false;\r\n    } else {\r\n      setAllErrors(prev => {\r\n        const next = { ...prev };\r\n        delete next[stepId];\r\n        return next;\r\n      });\r\n      setErrorSteps(prev => {\r\n        const next = new Set(prev);\r\n        next.delete(stepId);\r\n        return next;\r\n      });\r\n      return true;\r\n    }\r\n  }, [config.steps, wizardData]);\r\n\r\n  const validateAll = useCallback(async (): Promise<boolean> => {\r\n    let isValid = true;\r\n    for (const step of activeSteps) {\r\n      const stepValid = await validateStep(step.id);\r\n      if (!stepValid) isValid = false;\r\n    }\r\n    return isValid;\r\n  }, [activeSteps, validateStep]);\r\n\r\n  // Navigation\r\n  const goToStep = useCallback(async (stepId: string) => {\r\n    const targetIndex = activeSteps.findIndex(s => s.id === stepId);\r\n    if (targetIndex === -1) return;\r\n\r\n    // If moving forward, validate current\r\n    if (targetIndex > currentStepIndex) {\r\n       const shouldValidate = currentStep?.autoValidate ?? config.autoValidate ?? true;\r\n       if (shouldValidate) {\r\n         const isValid = await validateStep(currentStepId);\r\n         if (!isValid) return; // Block\r\n       }\r\n    }\r\n    \r\n    // Save current step data logic\r\n    if (persistenceMode === 'onStepChange' && currentStep) {\r\n        saveData('onStepChange', currentStepId, wizardData); \r\n    }\r\n\r\n    // Update State\r\n    const nextVisited = new Set(visitedSteps).add(currentStepId);\r\n    setVisitedSteps(nextVisited);\r\n    setCurrentStepId(stepId);\r\n    \r\n    // Persist Metadata (New Step Position)\r\n    // We need to pass the *new* values because state updates are async\r\n    if (persistenceMode !== 'manual') {\r\n        persistenceAdapter.saveStep(META_KEY, {\r\n            currentStepId: stepId,\r\n            visited: Array.from(nextVisited),\r\n            completed: Array.from(completedSteps)\r\n        });\r\n    }\r\n\r\n    window.scrollTo(0, 0);\r\n  }, [activeSteps, currentStepId, currentStep, currentStepIndex, config.autoValidate, persistenceMode, saveData, wizardData, validateStep, visitedSteps, completedSteps, persistenceAdapter]);\r\n\r\n  const goToNextStep = useCallback(async () => {\r\n     if (isLastStep) return;\r\n     const nextStep = activeSteps[currentStepIndex + 1];\r\n     if (nextStep) {\r\n        // Mark completed logic\r\n        const nextCompleted = new Set(completedSteps).add(currentStepId);\r\n        setCompletedSteps(nextCompleted);\r\n        \r\n        // Pass updated completed set to goToStep if we could, but goToStep uses state.\r\n        // We really should update metadata *after* state updates or pass explicit values.\r\n        // For simplicity, let's allow goToStep to handle transition, but we need to ensure 'completed' is saved.\r\n        // Let's update state, then call goToStep.\r\n        \r\n        await goToStep(nextStep.id);\r\n        \r\n        // Since goToStep saves metadata using *current* (stale) completedSteps state, \r\n        // we might miss the 'completed' update in storage until next move.\r\n        // FIX: Let's explicitly save metadata here with new values if needed, \r\n        // OR better: Just rely on React state consistency? No, inside async function state is stale.\r\n        \r\n        // Workaround: We'll save metadata again here with correct values.\r\n         if (persistenceMode !== 'manual') {\r\n             persistenceAdapter.saveStep(META_KEY, {\r\n                 currentStepId: nextStep.id,\r\n                 visited: Array.from(new Set(visitedSteps).add(currentStepId)),\r\n                 completed: Array.from(nextCompleted)\r\n             });\r\n         }\r\n     }\r\n  }, [activeSteps, currentStepIndex, isLastStep, currentStepId, goToStep, visitedSteps, completedSteps, persistenceMode, persistenceAdapter]);\r\n\r\n  const goToPrevStep = useCallback(() => {\r\n     if (isFirstStep) return;\r\n     const prevStep = activeSteps[currentStepIndex - 1];\r\n     if (prevStep) {\r\n       goToStep(prevStep.id);\r\n     }\r\n  }, [activeSteps, currentStepIndex, isFirstStep, goToStep]);\r\n\r\n  // Context Value\r\n  const value = {\r\n    currentStep,\r\n    currentStepIndex,\r\n    isFirstStep,\r\n    isLastStep,\r\n    isLoading,\r\n    activeSteps,\r\n    wizardData,\r\n    allErrors,\r\n    visitedSteps,\r\n    completedSteps,\r\n    errorSteps,\r\n    goToNextStep,\r\n    goToPrevStep,\r\n    goToStep,\r\n    setStepData,\r\n    handleStepChange,\r\n    validateStep,\r\n    validateAll,\r\n    save: () => saveData('manual', currentStepId, wizardData),\r\n    clearStorage: () => persistenceAdapter.clear(),\r\n  };\r\n\r\n  return <WizardContext.Provider value={value}>{children}</WizardContext.Provider>;\r\n}\r\n\r\nexport function useWizardContext<T = any>() {\r\n  const context = useContext(WizardContext);\r\n  if (!context) {\r\n    throw new Error('useWizardContext must be used within a WizardProvider');\r\n  }\r\n  return context as IWizardContext<T>;\r\n}\r\n","import type { IPersistenceAdapter } from '../../types';\r\n\r\nexport class MemoryAdapter implements IPersistenceAdapter {\r\n    private storage: Record<string, any> = {};\r\n\r\n    saveStep<T>(stepId: string, data: T): void {\r\n        this.storage[stepId] = data;\r\n    }\r\n\r\n    getStep<T>(stepId: string): T | undefined {\r\n        return this.storage[stepId] as T;\r\n    }\r\n\r\n    clear(): void {\r\n        this.storage = {};\r\n    }\r\n}\r\n","import { useWizardContext } from '../context/WizardContext';\r\n\r\nexport const useWizard = <T = any>() => {\r\n    return useWizardContext<T>();\r\n};\r\n","import type { IPersistenceAdapter } from '../../types';\r\n\r\nexport class LocalStorageAdapter implements IPersistenceAdapter {\r\n    private prefix: string;\r\n\r\n    constructor(prefix: string = 'wizard_') {\r\n        this.prefix = prefix;\r\n    }\r\n\r\n    private getKey(stepId: string): string {\r\n        return `${this.prefix}${stepId}`;\r\n    }\r\n\r\n    saveStep<T>(stepId: string, data: T): void {\r\n        if (typeof window === 'undefined') return;\r\n        try {\r\n            localStorage.setItem(this.getKey(stepId), JSON.stringify(data));\r\n        } catch (error) {\r\n            console.warn('LocalStorageAdapter: Failed to save step', error);\r\n        }\r\n    }\r\n\r\n    getStep<T>(stepId: string): T | undefined {\r\n        if (typeof window === 'undefined') return undefined;\r\n        try {\r\n            const item = localStorage.getItem(this.getKey(stepId));\r\n            return item ? JSON.parse(item) : undefined;\r\n        } catch (error) {\r\n            console.warn('LocalStorageAdapter: Failed to get step', error);\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        if (typeof window === 'undefined') return;\r\n        Object.keys(localStorage).forEach((key) => {\r\n            if (key.startsWith(this.prefix)) {\r\n                localStorage.removeItem(key);\r\n            }\r\n        });\r\n    }\r\n}\r\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\r\nimport { ZodType } from 'zod';\r\n\r\nexport class ZodAdapter<T> implements IValidatorAdapter<T> {\r\n    private schema: ZodType<T>;\r\n\r\n    constructor(schema: ZodType<T>) {\r\n        this.schema = schema;\r\n    }\r\n\r\n    async validate(data: T): Promise<ValidationResult> {\r\n        const result = await this.schema.safeParseAsync(data);\r\n        if (result.success) {\r\n            return { isValid: true };\r\n        }\r\n\r\n        // Explicitly handle error case\r\n        const errors: Record<string, string> = {};\r\n        result.error.issues.forEach((err) => {\r\n            const path = err.path.join('.'); // nested.field\r\n            errors[path] = err.message;\r\n        });\r\n        return { isValid: false, errors };\r\n    }\r\n}\r\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\r\nimport { Schema, ValidationError } from 'yup';\r\n\r\nexport class YupAdapter<T> implements IValidatorAdapter<T> {\r\n    private schema: Schema<T>;\r\n\r\n    constructor(schema: Schema<T>) {\r\n        this.schema = schema;\r\n    }\r\n\r\n    async validate(data: T): Promise<ValidationResult> {\r\n        try {\r\n            await this.schema.validate(data, { abortEarly: false });\r\n            return { isValid: true };\r\n        } catch (err) {\r\n            if (err instanceof ValidationError) {\r\n                const errors: Record<string, string> = {};\r\n                err.inner.forEach((error) => {\r\n                    if (error.path) {\r\n                        errors[error.path] = error.message;\r\n                    }\r\n                });\r\n                return { isValid: false, errors };\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["value"]}