{"version":3,"sources":["../src/context/WizardContext.tsx","../src/adapters/persistence/MemoryAdapter.ts","../src/utils/data.ts","../src/hooks/useWizard.ts","../src/adapters/persistence/LocalStorageAdapter.ts","../src/adapters/validation/ZodAdapter.ts","../src/adapters/validation/YupAdapter.ts"],"sourcesContent":["import React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  useSyncExternalStore,\n  useRef,\n  useTransition,\n} from \"react\";\nimport type {\n  IWizardConfig,\n  PersistenceMode,\n  IPersistenceAdapter,\n} from \"../types\";\nimport { MemoryAdapter } from \"../adapters/persistence/MemoryAdapter\";\nimport { getByPath, setByPath } from \"../utils/data\";\n\nconst WizardStateContext = createContext<any | undefined>(undefined);\nconst WizardActionsContext = createContext<any | undefined>(undefined);\n\n// Advanced: Store for granular subscriptions\nclass WizardStore<T> {\n  private state: { data: T; errors: Record<string, Record<string, string>> };\n  private listeners: Set<() => void> = new Set();\n\n  constructor(initialData: T) {\n    this.state = { data: initialData, errors: {} };\n  }\n\n  getSnapshot = () => this.state;\n\n  update(newData: T) {\n    this.state = { ...this.state, data: newData };\n    this.notify();\n  }\n\n  updateErrors(newErrors: Record<string, Record<string, string>>) {\n    this.state = { ...this.state, errors: newErrors };\n    this.notify();\n  }\n\n  private notify() {\n    this.listeners.forEach((l) => l());\n  }\n\n  subscribe = (listener: () => void) => {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  };\n}\n\ninterface WizardProviderProps<T> {\n  config: IWizardConfig<T>;\n  initialData?: T;\n  children: React.ReactNode;\n}\n\nexport function WizardProvider<T extends Record<string, any>>({\n  config,\n  initialData,\n  children,\n}: WizardProviderProps<T>) {\n  const [currentStepId, setCurrentStepId] = useState<string>(\"\");\n  const [visitedSteps, setVisitedSteps] = useState<Set<string>>(new Set());\n  const [completedSteps, setCompletedSteps] = useState<Set<string>>(new Set());\n  const [errorSteps, setErrorSteps] = useState<Set<string>>(new Set());\n  const [, setAllErrorsState] = useState<\n    Record<string, Record<string, string>>\n  >({});\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [isPending, startTransition] = useTransition();\n\n  // Store for granular data and errors\n  const storeRef = useRef(new WizardStore<T>((initialData || {}) as T));\n\n  // local state for dependencies\n  const [wizardData, setWizardData] = useState<T>((initialData || {}) as T);\n\n  // Persistence Setup\n  const persistenceAdapter = useMemo<IPersistenceAdapter>(() => {\n    return config.persistence?.adapter || new MemoryAdapter();\n  }, [config.persistence?.adapter]);\n\n  const persistenceMode = config.persistence?.mode || \"onStepChange\";\n\n  // Calculate Active Steps (Conditional Logic) - Stabilized to prevent global re-renders\n  const [activeSteps, setActiveSteps] = useState(() =>\n    config.steps.filter((s) => !s.condition || s.condition(wizardData))\n  );\n\n  useEffect(() => {\n    const nextActiveSteps = config.steps.filter((step) => {\n      if (step.condition) {\n        return step.condition(wizardData);\n      }\n      return true;\n    });\n\n    // Simple ID check for stability\n    const currentIds = activeSteps.map((s) => s.id).join(\",\");\n    const nextIds = nextActiveSteps.map((s) => s.id).join(\",\");\n\n    if (currentIds !== nextIds) {\n      setActiveSteps(nextActiveSteps);\n    }\n  }, [config.steps, wizardData, activeSteps]);\n\n  // Set initial step if not set\n  useEffect(() => {\n    if (!currentStepId && activeSteps.length > 0) {\n      setCurrentStepId(activeSteps[0].id);\n      setIsLoading(false);\n    }\n  }, [activeSteps, currentStepId]);\n\n  // Derived state\n  const currentStep = useMemo(\n    () => activeSteps.find((s) => s.id === currentStepId) || null,\n    [activeSteps, currentStepId]\n  );\n  const currentStepIndex = useMemo(\n    () => activeSteps.findIndex((s) => s.id === currentStepId),\n    [activeSteps, currentStepId]\n  );\n  const isFirstStep = currentStepIndex === 0;\n  const isLastStep = currentStepIndex === activeSteps.length - 1;\n\n  // Constants\n  const META_KEY = \"__wizzard_meta__\";\n\n  // Hydration Helper\n  const hydrate = useCallback(() => {\n    setIsLoading(true);\n\n    const metaFn = persistenceAdapter.getStep<{\n      currentStepId: string;\n      visited: string[];\n      completed: string[];\n    }>(META_KEY);\n\n    if (metaFn) {\n      if (metaFn.currentStepId) setCurrentStepId(metaFn.currentStepId);\n      if (metaFn.visited) setVisitedSteps(new Set(metaFn.visited));\n      if (metaFn.completed) setCompletedSteps(new Set(metaFn.completed));\n    }\n\n    const loadedData: Partial<T> = {};\n    config.steps.forEach((step) => {\n      const stepData = persistenceAdapter.getStep(step.id);\n      if (stepData) {\n        Object.assign(loadedData, stepData);\n      }\n    });\n\n    if (Object.keys(loadedData).length > 0) {\n      setWizardData((prev) => {\n        const newData = { ...prev, ...loadedData };\n        storeRef.current.update(newData);\n        return newData;\n      });\n    }\n    setIsLoading(false);\n  }, [config.steps, persistenceAdapter]);\n\n  useEffect(() => {\n    hydrate();\n  }, [hydrate]);\n\n  // Save logic stabilized\n  const saveData = useCallback(\n    (mode: PersistenceMode, stepId: string, data: any) => {\n      if (mode === persistenceMode || mode === \"manual\") {\n        persistenceAdapter.saveStep(stepId, data);\n      }\n    },\n    [persistenceAdapter, persistenceMode]\n  );\n\n  // Debounce timeout for validation\n  const validationTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(\n    null\n  );\n\n  const validateStep = useCallback(\n    async (stepId: string, data: T): Promise<boolean> => {\n      const step = config.steps.find((s) => s.id === stepId);\n      if (!step || !step.validationAdapter) return true;\n\n      const result = await step.validationAdapter.validate(data);\n\n      if (!result.isValid) {\n        const newAllErrors = {\n          ...storeRef.current.getSnapshot().errors,\n          [stepId]: result.errors || {},\n        };\n        storeRef.current.updateErrors(newAllErrors);\n        setAllErrorsState(newAllErrors);\n        setErrorSteps((prev) => {\n          const next = new Set(prev);\n          next.add(stepId);\n          return next;\n        });\n        return false;\n      } else {\n        const newAllErrors = { ...storeRef.current.getSnapshot().errors };\n        delete newAllErrors[stepId];\n        storeRef.current.updateErrors(newAllErrors);\n        setAllErrorsState(newAllErrors);\n        setErrorSteps((prev) => {\n          const next = new Set(prev);\n          next.delete(stepId);\n          return next;\n        });\n        return true;\n      }\n    },\n    [config.steps]\n  );\n\n  // Actions stabilized with useCallback\n  const setStepData = useCallback(\n    (stepId: string, data: any) => {\n      const prevData = storeRef.current.getSnapshot().data;\n      const newData = { ...prevData, ...data };\n\n      storeRef.current.update(newData);\n      startTransition(() => {\n        setWizardData(newData);\n      });\n\n      if (persistenceMode === \"onChange\") {\n        saveData(\"onChange\", stepId, newData);\n      }\n    },\n    [persistenceMode, saveData]\n  );\n\n  const setData = useCallback(\n    (path: string, value: any, options?: { debounceValidation?: number }) => {\n      const prevData = storeRef.current.getSnapshot().data;\n      const newData = setByPath(prevData, path, value);\n\n      // 1. Immediate store update (for useWizardValue)\n      storeRef.current.update(newData);\n\n      // 2. Transition update (for useWizardState/Summary)\n      startTransition(() => {\n        setWizardData(newData);\n      });\n\n      // 3. Debounced validation logic\n      if (options?.debounceValidation) {\n        if (validationTimeoutRef.current)\n          clearTimeout(validationTimeoutRef.current);\n        validationTimeoutRef.current = setTimeout(() => {\n          validateStep(currentStepId, newData);\n        }, options.debounceValidation);\n      } else {\n        validateStep(currentStepId, newData);\n      }\n\n      if (persistenceMode === \"onChange\") {\n        saveData(\"onChange\", currentStepId, newData);\n      }\n    },\n    [persistenceMode, saveData, currentStepId, validateStep]\n  );\n\n  const getData = useCallback((path: string, defaultValue?: any) => {\n    return getByPath(storeRef.current.getSnapshot().data, path, defaultValue);\n  }, []);\n\n  // Action: Handle specific field change (helper)\n  const handleStepChange = useCallback(\n    (field: string, value: any) => {\n      if (!currentStepId) return;\n      setData(field, value);\n    },\n    [setData, currentStepId]\n  );\n\n  const validateAll = useCallback(async (): Promise<boolean> => {\n    let isValid = true;\n    const currentData = storeRef.current.getSnapshot().data;\n    for (const step of activeSteps) {\n      const stepValid = await validateStep(step.id, currentData);\n      if (!stepValid) isValid = false;\n    }\n    return isValid;\n  }, [activeSteps, validateStep]);\n\n  const goToStep = useCallback(\n    async (stepId: string): Promise<boolean> => {\n      const targetIndex = activeSteps.findIndex((s) => s.id === stepId);\n      if (targetIndex === -1) return false;\n\n      const currentData = storeRef.current.getSnapshot().data;\n\n      if (targetIndex > currentStepIndex) {\n        const shouldValidate =\n          currentStep?.autoValidate ?? config.autoValidate ?? true;\n        if (shouldValidate) {\n          const isValid = await validateStep(currentStepId, currentData);\n          if (!isValid) return false;\n        }\n      }\n\n      if (persistenceMode === \"onStepChange\" && currentStep) {\n        saveData(\"onStepChange\", currentStepId, currentData);\n      }\n\n      const nextVisited = new Set(visitedSteps).add(currentStepId);\n      setVisitedSteps(nextVisited);\n      setCurrentStepId(stepId);\n\n      if (persistenceMode !== \"manual\") {\n        persistenceAdapter.saveStep(META_KEY, {\n          currentStepId: stepId,\n          visited: Array.from(nextVisited),\n          completed: Array.from(completedSteps),\n        });\n      }\n\n      window.scrollTo(0, 0);\n      return true;\n    },\n    [\n      activeSteps,\n      currentStepId,\n      currentStep,\n      currentStepIndex,\n      config.autoValidate,\n      persistenceMode,\n      saveData,\n      validateStep,\n      visitedSteps,\n      completedSteps,\n      persistenceAdapter,\n    ]\n  );\n\n  const goToNextStep = useCallback(async () => {\n    if (isLastStep) return;\n    const nextStep = activeSteps[currentStepIndex + 1];\n    if (nextStep) {\n      const success = await goToStep(nextStep.id);\n      if (success) {\n        const nextCompleted = new Set(completedSteps).add(currentStepId);\n        setCompletedSteps(nextCompleted);\n\n        if (persistenceMode !== \"manual\") {\n          persistenceAdapter.saveStep(META_KEY, {\n            currentStepId: nextStep.id,\n            visited: Array.from(new Set(visitedSteps).add(currentStepId)),\n            completed: Array.from(nextCompleted),\n          });\n        }\n      }\n    }\n  }, [\n    activeSteps,\n    currentStepIndex,\n    isLastStep,\n    currentStepId,\n    goToStep,\n    visitedSteps,\n    completedSteps,\n    persistenceMode,\n    persistenceAdapter,\n  ]);\n\n  const goToPrevStep = useCallback(() => {\n    if (isFirstStep) return;\n    const prevStep = activeSteps[currentStepIndex - 1];\n    if (prevStep) {\n      goToStep(prevStep.id);\n    }\n  }, [activeSteps, currentStepIndex, isFirstStep, goToStep]);\n\n  const clearStorage = useCallback(\n    () => persistenceAdapter.clear(),\n    [persistenceAdapter]\n  );\n\n  const save = useCallback(\n    () =>\n      saveData(\"manual\", currentStepId, storeRef.current.getSnapshot().data),\n    [saveData, currentStepId]\n  );\n\n  // Split values\n  const stateValue = useMemo(\n    () => ({\n      currentStep,\n      currentStepIndex,\n      isFirstStep,\n      isLastStep,\n      isLoading,\n      isPending,\n      activeSteps,\n      visitedSteps,\n      completedSteps,\n      errorSteps,\n      store: storeRef.current,\n    }),\n    [\n      currentStep,\n      currentStepIndex,\n      isFirstStep,\n      isLastStep,\n      isLoading,\n      isPending,\n      activeSteps,\n      visitedSteps,\n      completedSteps,\n      errorSteps,\n    ]\n  );\n\n  const actionsValue = useMemo(\n    () => ({\n      goToNextStep,\n      goToPrevStep,\n      goToStep,\n      setStepData,\n      handleStepChange,\n      validateStep: (sid: string) =>\n        validateStep(sid, storeRef.current.getSnapshot().data),\n      validateAll,\n      save,\n      clearStorage,\n      setData,\n      getData,\n    }),\n    [\n      goToNextStep,\n      goToPrevStep,\n      goToStep,\n      setStepData,\n      handleStepChange,\n      validateStep,\n      validateAll,\n      save,\n      clearStorage,\n      setData,\n      getData,\n    ]\n  );\n\n  return (\n    <WizardStateContext.Provider value={stateValue}>\n      <WizardActionsContext.Provider value={actionsValue}>\n        {children}\n      </WizardActionsContext.Provider>\n    </WizardStateContext.Provider>\n  );\n}\n\nexport function useWizardState() {\n  const context = useContext(WizardStateContext);\n  if (!context) {\n    throw new Error(\"useWizardState must be used within a WizardProvider\");\n  }\n  return context;\n}\n\nexport function useWizardValue<TValue = any>(path: string): TValue {\n  const { store } = useWizardState();\n  const lastStateRef = useRef<any>(null);\n  const lastValueRef = useRef<any>(null);\n\n  const getSnapshot = useCallback(() => {\n    const fullState = store.getSnapshot();\n    const data = fullState.data;\n    if (data === lastStateRef.current) {\n      return lastValueRef.current;\n    }\n    const value = getByPath(data, path);\n    lastStateRef.current = data;\n    lastValueRef.current = value;\n    return value;\n  }, [store, path]);\n\n  return useSyncExternalStore(store.subscribe, getSnapshot);\n}\n\nexport function useWizardError(path: string): string | undefined {\n  const { store } = useWizardState();\n  const lastStateRef = useRef<any>(null);\n  const lastValueRef = useRef<any>(null);\n\n  const getSnapshot = useCallback(() => {\n    const fullState = store.getSnapshot();\n    const errors = fullState.errors;\n    if (errors === lastStateRef.current) {\n      return lastValueRef.current;\n    }\n\n    // Flatten errors from all steps or use a specific step?\n    // Usually validation results are nested like { children: { \"0.name\": \"error\" } }\n    // but the adapter flattened them to \"children.0.name\"\n    let foundError: string | undefined;\n    Object.values(errors).forEach((stepErrors) => {\n      const typedStepErrors = stepErrors as Record<string, string>;\n      if (typedStepErrors[path]) foundError = typedStepErrors[path];\n    });\n\n    lastStateRef.current = errors;\n    lastValueRef.current = foundError;\n    return foundError;\n  }, [store, path]);\n\n  return useSyncExternalStore(store.subscribe, getSnapshot);\n}\n\nexport function useWizardSelector<TSelected = any>(\n  selector: (state: any) => TSelected\n): TSelected {\n  const { store } = useWizardState();\n  const lastStateRef = useRef<any>(null);\n  const lastResultRef = useRef<any>(null);\n\n  const getSnapshot = useCallback(() => {\n    const fullState = store.getSnapshot();\n    if (fullState === lastStateRef.current) {\n      return lastResultRef.current;\n    }\n    // We pass only data to the selector for convenience, or the whole store state?\n    // Let's pass the whole thing in case they need errors\n    const result = selector(fullState.data);\n    lastStateRef.current = fullState;\n    lastResultRef.current = result;\n    return result;\n  }, [store, selector]);\n\n  return useSyncExternalStore(store.subscribe, getSnapshot);\n}\n\nexport function useWizardActions() {\n  const context = useContext(WizardActionsContext);\n  if (!context) {\n    throw new Error(\"useWizardActions must be used within a WizardProvider\");\n  }\n  return context;\n}\n\nexport function useWizardContext<T = any>() {\n  const state = useWizardState();\n  const actions = useWizardActions();\n\n  // Backward compatibility: subscribe to everything\n  const wizardData = useWizardSelector<T>((s) => s as T);\n  const fullState = state.store.getSnapshot();\n\n  return useMemo(\n    () => ({\n      ...state,\n      ...actions,\n      wizardData,\n      allErrors: fullState.errors,\n    }),\n    [state, actions, wizardData, fullState.errors]\n  );\n}\n","import type { IPersistenceAdapter } from '../../types';\n\nexport class MemoryAdapter implements IPersistenceAdapter {\n    private storage: Record<string, any> = {};\n\n    saveStep<T>(stepId: string, data: T): void {\n        this.storage[stepId] = data;\n    }\n\n    getStep<T>(stepId: string): T | undefined {\n        return this.storage[stepId] as T;\n    }\n\n    clear(): void {\n        this.storage = {};\n    }\n}\n","/**\n * Retrieves a value from an object by path (dot notation or brackets)\n */\nexport function getByPath(obj: any, path: string, defaultValue?: any): any {\n    if (!path) return obj;\n    const keys = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.').filter(Boolean);\n    let result = obj;\n    for (const key of keys) {\n        if (result === undefined || result === null) return defaultValue;\n        result = result[key];\n    }\n    return result !== undefined ? result : defaultValue;\n}\n\n/**\n * Immutably sets a value in an object by path\n */\nexport function setByPath<T extends object>(obj: T, path: string, value: any): T {\n    if (!path) return value as unknown as T;\n    if (!path.includes('.') && !path.includes('[') && !path.includes(']')) {\n        return { ...obj, [path]: value };\n    }\n    const keys = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.').filter(Boolean);\n\n    const update = (current: any, index: number): any => {\n        if (index === keys.length) return value;\n\n        const key = keys[index];\n        const isKeyNumeric = !isNaN(Number(key)) && key.trim() !== '';\n\n        let nextLevel = current;\n        if (!nextLevel || typeof nextLevel !== 'object') {\n            nextLevel = isKeyNumeric ? [] : {};\n        } else {\n            nextLevel = Array.isArray(nextLevel) ? [...nextLevel] : { ...nextLevel };\n        }\n\n        const nextKey = isKeyNumeric ? Number(key) : key;\n        nextLevel[nextKey] = update(nextLevel[nextKey], index + 1);\n        return nextLevel;\n    };\n\n    return update(obj, 0);\n}\n","import { useWizardContext } from '../context/WizardContext';\n\nexport const useWizard = <T = any>() => {\n    return useWizardContext<T>();\n};\n","import type { IPersistenceAdapter } from '../../types';\n\nexport class LocalStorageAdapter implements IPersistenceAdapter {\n    private prefix: string;\n\n    constructor(prefix: string = 'wizard_') {\n        this.prefix = prefix;\n    }\n\n    private getKey(stepId: string): string {\n        return `${this.prefix}${stepId}`;\n    }\n\n    saveStep<T>(stepId: string, data: T): void {\n        if (typeof window === 'undefined') return;\n        try {\n            localStorage.setItem(this.getKey(stepId), JSON.stringify(data));\n        } catch (error) {\n            console.warn('LocalStorageAdapter: Failed to save step', error);\n        }\n    }\n\n    getStep<T>(stepId: string): T | undefined {\n        if (typeof window === 'undefined') return undefined;\n        try {\n            const item = localStorage.getItem(this.getKey(stepId));\n            return item ? JSON.parse(item) : undefined;\n        } catch (error) {\n            console.warn('LocalStorageAdapter: Failed to get step', error);\n            return undefined;\n        }\n    }\n\n    clear(): void {\n        if (typeof window === 'undefined') return;\n        Object.keys(localStorage).forEach((key) => {\n            if (key.startsWith(this.prefix)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n}\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\nimport type { ZodLikeSchema } from './internal-types';\n\nexport class ZodAdapter<T> implements IValidatorAdapter<T> {\n    private schema: ZodLikeSchema<T>;\n\n    constructor(schema: ZodLikeSchema<T>) {\n        this.schema = schema;\n    }\n\n    async validate(data: T): Promise<ValidationResult> {\n        const result = await this.schema.safeParseAsync(data);\n        if (result.success) {\n            return { isValid: true };\n        }\n\n        // Explicitly handle error case\n        const errors: Record<string, string> = {};\n        if (result.error) {\n            result.error.issues.forEach((err) => {\n                const path = err.path.join('.'); // nested.field\n                errors[path] = err.message;\n            });\n        }\n        return { isValid: false, errors };\n    }\n}\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\nimport type { YupLikeSchema, YupLikeError } from './internal-types';\n\nexport class YupAdapter<T> implements IValidatorAdapter<T> {\n    private schema: YupLikeSchema<T>;\n\n    constructor(schema: YupLikeSchema<T>) {\n        this.schema = schema;\n    }\n\n    async validate(data: T): Promise<ValidationResult> {\n        try {\n            await this.schema.validate(data, { abortEarly: false });\n            return { isValid: true };\n        } catch (err) {\n            if (err && typeof err === 'object' && 'inner' in err) {\n                const yupError = err as YupLikeError;\n                const errors: Record<string, string> = {};\n                yupError.inner.forEach((error) => {\n                    if (error.path) {\n                        errors[error.path] = error.message;\n                    }\n                });\n                return { isValid: false, errors };\n            }\n            throw err;\n        }\n    }\n}\n"],"mappings":"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","names":[]}